#modgen

#include "py/emitglue.h"
#include "py/parse.h"
#include "py/lexer.h"
#include "py/compile.h"

extern mp_lexer_t* mp_lexer_new_from_file(const char *filename);

// Save .mpy file to file system
int raw_code_save_file(mp_raw_code_t *rc, const char *filename) {  return 0; }


def os_read() -> bytes:
    // simple read string

    static char buf[256];
    //fputs(p, stdout);
    char *s = fgets(buf, sizeof(buf), stdin);
    if (!s) {
        //return mp_obj_new_int(0);
        buf[0]=0;
        fprintf(stderr,"embed.os_read EOF\n" );
    } else {
        int l = strlen(buf);
        if (buf[l - 1] == '\n') {
            if ( (l>1) && (buf[l - 2] == '\r') )
                buf[l - 2] = 0;
            else
                buf[l - 1] = 0;
        } else {
            l++;
        }
        fprintf(stderr,"embed.os_read [%s]\n", buf );
    }
    return bytes(buf);
    # py comment #1


def vars(module_obj : mp_obj_t = None ) -> dict:
    mp_obj_dict_t *mod_globals = mp_obj_module_get_globals(module_obj);
    return mod_globals;


def raw_code_save_file(rc:mp_raw_code_t="", filename:str="") -> int:
    /*
    RTOS_ERR rtos_err;

    fh_t file_handle = file_open(wrk_dir_handle,
                                           filename,
                                           ACCESS_MODE_WR
                                               | ACCESS_MODE_CREATE
                                               | ACCESS_MODE_TRUNCATE,
                                           &rtos_err);
    check_rtos_err_raise(file_handle, RTOS_ERR_CODE_GET(rtos_err));

    mp_print_t code_print = { (void*)(intptr_t)file_handle,
                              file_write_strn };
    mp_raw_code_save(rc, &code_print);
    int ret = file_seek(file_handle, 0, ORIGIN_CUR, &rtos_err);
    file_close(file_handle, &rtos_err);
    return ret;
    */
    return 0;


def os_compile(source_file : const_char_p="", mpy_file : const_char_p="") -> void:
    vstr_t vstr;

    if (argc == 2 && argv[1] != mp_const_none) {
        mpy_file = mp_obj_str_get_str(argv[1]);
    } else {
        vstr_init(&vstr, strlen(source_file) + 5);  // +5 for NUL and .mpy
        vstr_add_str(&vstr, source_file);
        if (vstr.len > 3 && memcmp(&vstr.buf[vstr.len - 3], ".py", 3) == 0) {
            // remove .py extension to replace with .mpy
            vstr_cut_tail_bytes(&vstr, 3);
        }
        vstr_add_str(&vstr, ".mpy");

        mpy_file = vstr_null_terminated_str(&vstr);
    }

    //gc_collect();
    //mp_micropython_mem_info(0, NULL);

    mp_printf(MP_PYTHON_PRINTER, "Parsing %s...\n", source_file);
    mp_parse_tree_t parse_tree = mp_parse(mp_lexer_new_from_file(source_file),
                                          MP_PARSE_FILE_INPUT);
    //gc_collect();
    //mp_micropython_mem_info(0, NULL);

    mp_printf(MP_PYTHON_PRINTER, "Compiling...\n");
    mp_raw_code_t *rc = mp_compile_to_raw_code(&parse_tree,
                                               qstr_from_str(source_file),
                                               MP_EMIT_OPT_NONE,
                                               false);
    //gc_collect();
    //mp_micropython_mem_info(0, NULL);

    mp_printf(MP_PYTHON_PRINTER, "Saving %s...\n", mpy_file);
    raw_code_save_file(rc, mpy_file);

    return mp_const_none;


def echosum1(num : int=0) -> int:
    return MP_OBJ_NEW_SMALL_INT(num+1);

# py comment #2

def callsome(fn : void=npe) -> void:
    (*fn)();


def somecall(s:str='pouet'):
    fprintf(stderr, "FPRINTF[%s]\n", mp_obj_str_get_str(s) );
    print(s);

// c comment #3

