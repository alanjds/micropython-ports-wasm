import sys,typing

def npe():
    print('Null Pointer Exception')

void = typing.TypeVar('void')
mp_raw_code_t = typing.TypeVar('mp_raw_code_t*')
const_char_p = typing.TypeVar('const char*')
mp_obj_t = typing.TypeVar('mp_obj_t*')


class empty:pass

instance = empty()


def py2c(modname, source, clines):
    global namespace, instance
    header = len(clines)
    append = 0
    prepend = 0
    namespace = modname
    pylines = [f"class module:"]
    defs = []
    isdef = ''
    defcount = 0
    defmap = []


    def end_def():
        if isdef!='':
            trail = []
            while (not len(clines[-1].strip())) or (clines[-1].strip().startswith('//')):
                trail.insert(0,clines.pop() )

            clines.append('} /* %s */' % isdef)
            append = len(clines)

            clines.extend( trail )

            defmap.append( [ isdef, prepend, append ] )
            print(defmap[-1])

    for l in source.readlines():
        l = l.rstrip()

        if len(l) and l.strip()[0] == "#":
            if not l.strip().startswith('#include '):
                clines.append('//'+l[1:])
                continue

        if len(l) < 4:
            clines.append("")
            continue

        if l.startswith('def '):
            end_def()
            pylines.append(f"    {l} pass")
            pylines.append('')

            isdef = l[4:-1].split('(',1)[0].strip()
            defcount+=1
            clines.append("/* #%s@%s %s  */" % (defcount,len(clines),l[4:-1].strip() ))
            prepend = 1+len(clines)

            continue

        clines.append(l)

    end_def()



    clines.insert(header, """/*
  %(namespace)s AUTO-GENERATED by %(name)s
*/


#include <string.h>
#include <stdio.h>

#include "py/obj.h"
#include "py/runtime.h"

static void print(mp_obj_t str) {
    mp_obj_print(str, PRINT_STR);
    mp_obj_print(mp_obj_new_str_via_qstr("\\n",1), PRINT_STR);
}

static void null_pointer_exception(void){
    fprintf(stderr, "null pointer exception in function pointer call\\n");
}

STATIC mp_obj_t PyBytes_FromString(char *string){
    vstr_t vstr;
    vstr_init_len(&vstr, strlen(string));
    strcpy(vstr.buf, string);
    return mp_obj_new_str_from_vstr(&mp_type_bytes, &vstr);
}

#define None mp_const_none
#define bytes(cstr) PyBytes_FromString(cstr)

    """  % {'namespace': namespace, 'name': sys.argv[0]} )

    return pylines, defmap


